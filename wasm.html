<!doctype html>
<html lang="zh">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OpenCC WASM Low-Level API 演示</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/style.css">
  <style>
    #configButtons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    #configButtons button {
      background: white;
      color: var(--text-main);
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    #configButtons button:hover {
      border-color: var(--primary);
      background: #f0fdf4;
    }

    .status-log {
      font-family: monospace;
      font-size: 0.85rem;
      background: #2d2d2d;
      color: #e5e5e5;
      padding: 12px;
      border-radius: 8px;
    }

    input[type="text"] {
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      width: 100%;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <div class="brand">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 152 152">
          <path fill="currentColor"
            d="M64.7 9.7c-.4.3.3 1.7 1.5 3 1.9 2 2.3 3.6 2.3 8.6v6.2L53 29.7c-8.5 1.3-17.4 2.7-19.7 3.1-3.8.8-4.3.7-6.6-1.9-3.1-3.6-6.2-4-5-.7 1.5 4.2.6 10.7-2.3 16.4-2.6 5.2-2.7 5.8-1.3 8.2.8 1.5 2.1 2.7 2.9 2.7 2 0 4.7-5.8 6.3-13.5l1.3-6.4L39 35.8c18.6-3.1 45.1-5.8 61-6 17.9-.3 18.7.2 12.4 7.2-2 2.2-3.5 4.3-3.2 4.5.3.3 3-.6 6.2-2.1 3.9-1.8 6.9-2.5 9.8-2.2 5.9.4 6.3-2.1 1.1-7.4-5.3-5.5-8.3-6.9-12.4-5.8-1.9.4-9.5 1.1-16.9 1.5-7.4.3-15.4.8-17.7 1.2l-4.3.5.6-3.3c.4-1.9 1.3-4.7 2.1-6.2 1.1-2.3 1.2-3.1.2-4.3-2.5-3.1-11.4-5.5-13.2-3.7z" />
          <path fill="currentColor"
            d="M87 43.5c-1.4.8-3.4 1.4-4.5 1.4s-9.3 1.5-18.3 3.3c-13.9 2.7-16.7 3-19.4 2-5-1.9-5.7.1-1.4 4.4 4.1 4.1 3.7 4.1 16.6-.4 9.1-3.3 26-6.5 27.3-5.3.7.7-7.9 11.8-12.1 15.4-1.9 1.8-2.2 1.8-4.4.3-4.9-3.5-5-1.4-.3 5.5 5.2 7.6 4.9 8.6-3.2 9.4-3.8.4-16.1 2-27.6 3.6-15.1 2.2-21.2 2.7-22.6 1.9-5.2-2.7-6.8.1-2.4 4.2 5.1 4.6 6.1 4.8 13.2 2.1C34 89 55.2 85 68.7 83.6l6.2-.7.7 3.7c1 5.5-.3 25.2-2.1 31.2-.9 2.9-2.3 5.6-3.2 5.9-1.4.6-8.4-.5-15-2.3-4.5-1.2-2.3 1.6 3.3 4.3 3.8 1.8 6.3 3.8 8 6.5 1.3 2.1 3.1 3.8 4 3.8 2.9 0 6.3-4.8 8.6-12.1 2-6.5 2.3-9.4 2.3-24.2V83l3.4-.6c3.6-.7 28.3.1 40.4 1.2 6.4.7 6.7.6 6.7-1.5 0-1.7-1.3-2.8-5.5-4.7-5-2.3-6-2.4-10.7-1.5-2.9.6-12.1 1.3-20.4 1.7l-15.1.7-2.3-4.7-2.2-4.7 6.8-6.4c3.8-3.5 9.3-7.7 12.1-9.2 2.9-1.5 5.3-3.4 5.3-4 0-1.4-7.7-7.3-9.4-7.3-.6.1-2.2.7-3.6 1.5z" />
        </svg>
        <div>
          <h1>OpenCC WASM Low-Level API</h1>
          <span>底層 API 演示</span>
        </div>
      </div>
      <div class="chips">
        <a href="index.html" class="chip" style="text-decoration:none;">首頁 Home</a>
        <a href="https://github.com/frankslin/OpenCC/tree/master/wasm-lib" target="_blank" class="chip"
          style="text-decoration:none;">GitHub</a>
        <a href="https://www.npmjs.com/package/opencc-wasm" target="_blank" class="chip"
          style="text-decoration:none;">npm</a>
      </div>
    </header>

    <div class="card-section">
      <h2>加载配置与词典</h2>
      <p style="color:var(--text-sub);">点击配置名，手动写入虚拟文件系统 <code>/data/config/</code>。</p>
      <div id="configButtons"></div>
    </div>

    <div class="card-section">
      <h2>文本转换</h2>
      <div class="options">
        <div>
          <label>配置名称</label>
          <input id="configPath" type="text" placeholder="尚未选择配置" disabled style="background:#f3f4f6;" />
        </div>
        <div>
          <label>待转换文本</label>
          <input id="textInput" type="text" placeholder="汉字" />
        </div>
      </div>
      <div class="toolbar">
        <button id="runConvert" class="btn btn-primary" disabled>执行转换</button>
      </div>

      <div style="margin-top: 16px;">
        <label>转换结果</label>
        <div style="display:flex; align-items:flex-start; gap:8px;">
          <div class="output-box" id="convertOutput" style="min-height: 80px;"></div>
          <button id="copyOutput" class="btn btn-secondary" style="padding: 8px 12px;">复制</button>
        </div>
      </div>
    </div>

    <div class="card-section">
      <h2>运行测试用例</h2>
      <button id="runTests" class="btn btn-secondary">运行测试</button>
    </div>

    <div class="card-section">
      <h2>日志</h2>
      <pre id="logOutput" class="status-log"></pre>
    </div>

    <div class="footer">
      <p class="chips">
        <a href="index.html" class="chip" style="text-decoration:none;">首頁 Home</a>
        <a href="https://github.com/frankslin/OpenCC/tree/master/wasm-lib" class="chip" target="_blank">OpenCC WASM</a>
        <a href="https://github.com/BYVoid/OpenCC" class="chip" target="_blank">OpenCC</a>
        <a href="https://www.npmjs.com/package/opencc-wasm" class="chip" target="_blank">npm</a>
        <a href="https://t.me/+TVq4LmPRlN9hZjE0" class="chip" target="_blank">Telegram</a>
      </p>
      <p>WASM Low-Level API 演示頁。基於 <a href="https://www.npmjs.com/package/opencc-wasm" target="_blank"
          rel="noreferrer">opencc-wasm</a> 於本地執行。</p>
      <p style="font-size: 0.8rem;">
        OpenCC is open source software licensed under <a href="https://www.apache.org/licenses/LICENSE-2.0"
          target="_blank">Apache 2.0</a>. Copyright © OpenCC contributors.
      </p>
    </div>
  </div>

  <script type="module">
    let cachedFactory = null;
    const vendorBase = new URL("./vendor/opencc-wasm/", window.location.href);
    const locateFile = (path) => new URL(path, vendorBase).href;
    async function loadWasmFactory() {
      if (cachedFactory) return cachedFactory;
      const url = new URL("esm/opencc-wasm.js", vendorBase).href;
      const mod = await import(url);
      cachedFactory = mod.default;
      return cachedFactory;
    }

    let Module = null;
    let Api = null;
    const handles = new Map();
    const loadedConfigs = new Set();
    const loadedDicts = new Set();
    const readableNames = new Map();

    const initModule = async () => {
      if (!Module) {
        const createOpenCCWasm = await loadWasmFactory();
        Module = await createOpenCCWasm({ locateFile });
      }
      if (!Api) {
        Api = {
          create: Module.cwrap("opencc_create", "number", ["string"]),
          convert: Module.cwrap("opencc_convert", "string", ["number", "string"]),
          destroy: Module.cwrap("opencc_destroy", null, ["number"]),
        };
      }
      return Module;
    };

    document.getElementById("runConvert").onclick = async () => {
      const mod = await initModule();
      const cfgInput = document.getElementById("configPath");
      const cfg = cfgInput.dataset.path;
      const handle = Number(cfgInput.dataset.handle || 0);
      const ready = cfgInput.dataset.ready === "1";
      if (!cfg) {
        document.getElementById("convertOutput").textContent = "请选择配置后再转换";
        return;
      }
      if (!ready) {
        document.getElementById("convertOutput").textContent = "词典未加载成功，无法转换";
        return;
      }
      if (!handle) {
        document.getElementById("convertOutput").textContent = "转换句柄未就绪";
        return;
      }
      const text = document.getElementById("textInput").value || "汉字";
      document.getElementById("convertOutput").textContent = Api.convert(handle, text);
    };

    const collectOcd2Files = (dictNode, acc) => {
      if (!dictNode || typeof dictNode !== "object") return;
      if (dictNode.type === "ocd2" && dictNode.file) {
        acc.add(dictNode.file);
      }
      if (dictNode.type === "group" && Array.isArray(dictNode.dicts)) {
        dictNode.dicts.forEach(d => collectOcd2Files(d, acc));
      }
    };

    const loadConfigAndDicts = async (cfgName) => {
      if (handles.has(cfgName) && loadedConfigs.has(cfgName)) {
        const cfgPath = `/data/config/${cfgName}`;
        const cfgInput = document.getElementById("configPath");
        const label = readableNames.get(cfgName) || cfgName;
        cfgInput.value = label;
        cfgInput.dataset.path = cfgPath;
        cfgInput.dataset.handle = String(handles.get(cfgName));
        cfgInput.dataset.ready = "1";
        document.getElementById("runConvert").disabled = false;
        document.getElementById("logOutput").textContent = `已缓存：${label}`;
        return handles.get(cfgName);
      }
      const mod = await initModule();
      const out = document.getElementById("logOutput");
      if (!mod.FS || !mod.FS.writeFile) {
        out.textContent = "FS not available; ensure build with -s FORCE_FILESYSTEM=1";
        throw new Error("FS not available");
      }
      try {
        out.textContent = `Fetching ${cfgName}...`;
        try { mod.FS.mkdir("/data"); } catch (e) { }
        try { mod.FS.mkdir("/data/config"); } catch (e) { }
        try { mod.FS.mkdir("/data/dict"); } catch (e) { }

        const base = vendorBase.href;
        const cfgUrl = `${base}data/config/${cfgName}`;
        const cfgResp = await fetch(cfgUrl);
        if (!cfgResp.ok) throw new Error(`${cfgUrl} -> HTTP ${cfgResp.status}`);
        const cfgJson = await cfgResp.json();
        const dicts = new Set();
        collectOcd2Files(cfgJson.segmentation?.dict, dicts);
        if (Array.isArray(cfgJson.conversion_chain)) {
          cfgJson.conversion_chain.forEach(item => collectOcd2Files(item?.dict, dicts));
        }

        const written = [`/data/config/${cfgName}`];
        for (const file of dicts) {
          const url = `${base}data/dict/${file}`;
          if (!loadedDicts.has(file)) {
            const resp = await fetch(url);
            if (!resp.ok) throw new Error(`${url} -> HTTP ${resp.status}`);
            const buf = new Uint8Array(await resp.arrayBuffer());
            mod.FS.writeFile(`/data/dict/${file}`, buf);
            loadedDicts.add(file);
          }
          written.push(`/data/dict/${file}`);
        }

        const patchPaths = (node) => {
          if (!node || typeof node !== "object") return;
          if (node.type === "ocd2" && node.file) {
            node.file = `/data/dict/${node.file}`;
          }
          if (node.type === "group" && Array.isArray(node.dicts)) {
            node.dicts.forEach(patchPaths);
          }
        };
        patchPaths(cfgJson.segmentation?.dict);
        if (Array.isArray(cfgJson.conversion_chain)) {
          cfgJson.conversion_chain.forEach(item => patchPaths(item?.dict));
        }
        const cfgText = JSON.stringify(cfgJson);
        mod.FS.writeFile(`/data/config/${cfgName}`, cfgText);

        const cfgPath = `/data/config/${cfgName}`;
        if (handles.has(cfgName)) {
          Api.destroy(handles.get(cfgName));
        }
        const handle = Api.create(cfgPath);
        if (!handle || handle < 0) {
          throw new Error("opencc_create failed");
        }
        handles.set(cfgName, handle);
        loadedConfigs.add(cfgName);
        const cfgNameReadable = cfgJson.name || cfgName;
        readableNames.set(cfgName, cfgNameReadable);
        out.textContent = `Config: ${cfgNameReadable}\nAll files written:\n` + written.join("\n");
        const cfgInput = document.getElementById("configPath");
        cfgInput.value = cfgNameReadable;
        cfgInput.dataset.path = cfgPath;
        cfgInput.dataset.handle = String(handle);
        cfgInput.dataset.ready = "1";
        document.getElementById("runConvert").disabled = false;
        document.getElementById("textInput").focus();
        return handle;
      } catch (err) {
        out.textContent = "Fetch/write failed: " + err;
        const cfgInput = document.getElementById("configPath");
        cfgInput.dataset.ready = "0";
        document.getElementById("runConvert").disabled = true;
        throw err;
      }
    };

    const configFiles = [
      "hk2s.json", "hk2t.json", "jp2t.json", "s2hk.json", "s2t.json", "s2twp.json",
      "s2tw.json", "t2hk.json", "t2jp.json", "t2s.json", "t2tw.json",
      "tw2s.json", "tw2t.json", "tw2sp.json"
    ];
    const btnContainer = document.getElementById("configButtons");
    configFiles.forEach(name => {
      const btn = document.createElement("button");
      btn.textContent = name;
      btn.onclick = () => loadConfigAndDicts(name);
      btnContainer.appendChild(btn);
    });

    document.getElementById("runTests").onclick = async () => {
      const out = document.getElementById("logOutput");
      out.textContent = "Loading testcases...";
      try {
        const resp = await fetch("./testcases.json");
        if (!resp.ok) throw new Error(`testcases.json HTTP ${resp.status}`);
        const parsed = await resp.json();
        const cases = Array.isArray(parsed?.cases) ? parsed.cases : [];
        if (cases.length === 0) {
          out.textContent = "No testcases found.";
          return;
        }
        const cfgSet = new Set();
        cases.forEach(tc => {
          if (tc.expected && typeof tc.expected === "object") {
            Object.keys(tc.expected).forEach(cfg => cfgSet.add(`${cfg}.json`));
          }
        });
        for (const cfg of cfgSet) {
          await loadConfigAndDicts(cfg);
        }
        let passed = 0;
        let total = 0;
        const lines = [];
        cases.forEach((tc) => {
          if (!tc.expected || typeof tc.expected !== "object") return;
          Object.entries(tc.expected).forEach(([cfg, expected]) => {
            total++;
            const cfgName = `${cfg}.json`;
            const handle = handles.get(cfgName);
            if (!handle) throw new Error(`missing handle for ${cfgName}`);
            const actual = Api.convert(handle, tc.input);
            const ok = actual === expected;
            if (ok) {
              passed++;
              lines.push(`✔ [${cfgName}] ${tc.input} -> ${actual}`);
            } else {
              lines.push(`✘ [${cfgName}] ${tc.input}\n  expected: ${expected}\n  actual:   ${actual}`);
            }
          });
        });
        const failed = total - passed;
        let msg = `Total assertions: ${total}, Passed: ${passed}, Failed: ${failed}`;
        msg += `\n\nDetails:\n${lines.join("\n")}`;
        out.textContent = msg;
      } catch (err) {
        out.textContent = "Run tests failed: " + err;
      }
    };

    document.getElementById("copyOutput").onclick = async () => {
      const text = document.getElementById("convertOutput").textContent;
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        const btn = document.getElementById("copyOutput");
        const old = btn.textContent;
        btn.textContent = "已复制";
        setTimeout(() => (btn.textContent = old), 1200);
      } catch (err) {
        alert("复制失败: " + err);
      }
    };
  </script>
</body>

</html>